# 蒙哥马利模乘-大数模乘

# 大数乘法

在[蒙哥马利模乘-分析.md](蒙哥马利模乘-分析.md)中分析了蒙哥马利相关算法，我们将256-bit的乘法拆成四轮，即每轮是$2^{64}$乘以一个256-bit的大数。

接下来我们先定义一个乘法函数：
```c
// 乘法结果 r = k * b
static void gm_i_bn_mul(uint64_t * r, const uint64_t * k, const gm_bn_t b);
```
其中k是一个$2^{64}$的数，因为我们是用数组来表示，数组每个元素只存$2^{32}$的数，所以这里的k是一个含有2个元素的数组，(k * b)乘法的结果理论uint64_t r[10]是可以存的下的。
下面我们看一下乘法算法：

``` 
   b7b6b5b4b3b2b1b0
x              k1k0

k0b0*2^0*8 
k0b1*2^1*8 + k1b0*2^1*8
k0b2*2^2*8 + k1b1*2^2*8
k0b3*2^3*8 + k1b2*2^3*8
k0b4*2^4*8 + k1b3*2^4*8
k0b5*2^5*8 + k1b4*2^5*8
k0b6*2^6*8 + k1b5*2^6*8
k0b7*2^7*8 + k1b6*2^7*8
             k1b7*2^8*8

结果（数组下标从0开始）：k0b0, k0b1+k1b0, .. ,k0b7+k1b6, k1b7

 k * b
   b7b6b5b4b3b2b1b0
x              k1k0

k0k1b0b1
k0k1b2b3*2^2*8 
k0k1b4b5*2^4*8 
k0k1b6b7*2^6*8
k0k1b0b1, k0k1b2b3, .. ,k0k1b6b7
```
将这个乘法拆成两轮，先来看第一轮：
``` c
uint64_t t = 0;
for(j = 0; j < 8; j++) {
	t = k[0] * b[j] + t;
	r[j] = t & 0x0FFFFFFFFULL;
	t >>= 32;
}
r[8] = t;
```
大家可以把循环展开看一下，这里用t存过程计算结果，r每个元素只存乘法的低32位，高32位加到下一轮的结果中，循环结束后，最后的高32位加到r[8]中。

下面看第二轮：
``` c
uint64_t t = 0;
for(j = 0; j < 8; j++) {
	t = r[1 + j] + k[1] * b[j] + t;
	r[1 + j] = t & 0x0FFFFFFFFULL;
	t >>= 32;
}
r[1 + 8] = t;
```
第二轮，j=0时，乘法结果应该存在r[1]中吧，另外还得加上第一轮r[1]中的数，这里的t会溢出吗？
结果是不会溢出的，因为r[1+j]是一个32位的数，t也是一个32位的数，乘法的结果加上两32位的数，最大值是每个字节刚好都为FF，大家可以用计算器算一下。

合并两轮循环，最终算法为：

``` c
static void gm_i_bn_mul(uint64_t * r, const uint64_t * k, const gm_bn_t b) {
    int i, j;
    // k0b0, k0b1+k1b0, .. ,k0b7+k1b6, k1b7
    uint64_t t;

    for(i = 0; i < 2; i++) {
        t = 0;
        for (j = 0; j < 8; j++) {
            t = r[i + j] + k[i] * b[j] + t;
            r[i + j] = t & 0x0FFFFFFFFULL;
            t >>= 32;
        }
        r[i + 8] = t;
    }
}
```

# t的计算

在计算q值过程中，还有一个t的计算，先回顾q的公式：

$q\ =\ (a[0]*b[i]+d_0)*t\ (mod\ 2^{32})$

注意这里，我们对$2^{64}$取模，因为我们是将256-bit拆成四轮乘法，所以每轮是除以$2^{64}$。

伪代码为：
``` c
t = 1;
for(i = 1; i < 64; i++) {
	t = t * t * p mod 2^64;
}
t = 2^64 - t;
```
代码实现：

```c
uint64_t t = 1;
for(i = 1; i < 64; i++) {
    t = t * t;
    t = t * (m[0] | m[1] << 32);
}
t = 0xFFFFFFFFFFFFFFFF - t + 1;
```
这里的m即国密推荐曲线中的p或n。

最终计算结果分别是：
$t = -p^{-1}\ (mod\ 2^{64})=0x01$
$t = -n^{-1}\ (mod\ 2^{64})=0x327F9E8872350975ULL$

