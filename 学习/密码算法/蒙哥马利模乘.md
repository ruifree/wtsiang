# 思路分析
## 模乘分析

对于一个512-bit 及以上的大数，要计算mod p或mod n是不好计算的，所以就要想，有没有办法**边计算乘法结果，边取模**，蒙哥马利算法就是这个思路。

我们先拿4字节数来举例，后面再扩展到256bit大数

```
   0x01020304
x  0x05060708
```
按小学数学，结果应该是：

$0x08*0x01020304+0x07*0x01020304*2^8+0x06*0x01020304*2^{16}+0x05*0x01020304*2^{24}$

所以需要经过4轮计算，将每轮结果相加就是乘法的结果了，再假设：

```
      FFFFFFFF
x           FF
=   FEFFFFFF01
```
这一轮中，都是数值中的最大值，乘法结果为FEFFFFFF01，结果不会超过5字节，如何把它变成4字节呢？

$\frac{FEFFFFFF01}{2^8}$

除以$2^8$即可，这里都是最大值FF来举例的目的，就是让大家清楚，会不会溢出，应该用多大的内存才存的下乘法结果。


也就是说，只要每一轮计算结果都除以$2^8$，最终的结果也会是4字节，计算4字节mod n或mod p就很简单了（这里暂时假设p和n也就4字节的素数）。

那么这样a * b每轮都除以$2^{32}$计算乘法结果，最后再对p取模，结果应该是:

$\frac{a*b}{2^{32}}\ (mod\ p) \equiv a*b*2^{-32}\ (mod\ p)$

这里有两个问题：

<mark>1) 每轮乘法的结果并不一定是$2^8$的倍数，除法就有困难;</mark>
<mark>2) 最终的结果是$a*b*2^{-32}\ (mod\ p)$，并不是$a*b\ (mod\ p)$接下来解决这两个问题即可;</mark>

## 每轮结果处理

在上述每轮的结果中，我们加上的 `q*p`，只要是p的倍数，那么最终结果对p取模都是一样的。
进一步推导$a*b*2^{-32}\ (mod\ p)$这个计算过程中，无论每一轮我们加上多少个`q*p`，结果都是一样的。
再进一步推导，只要我们想办法让每一轮加上`q*p`正好是$2^{32}$的倍数，不就可以解决上述提到的**第1个问题**。
也就是我们计算的重心转移到了计算q这个值去了，满足这种条件的q在除以$2^{32}$时，可以直接丢弃低32位即可。


## 中途总结
写个伪代码，假设有4字节数a * b，对p取模，我们用uint8_t来表示这个数（忽略中间结果溢出问题先）：
``` c
uint8_t a[4]
uint8_t b[4]
uint8_t d[5]
```
每轮结果用d来存放，回顾一下d用5个字节就可以了吧。

``` c
d = 0;
for(i = 0; i < 4; i++) {
	d = ((b[i] * a) + d + q * p) * 2^-8;
}
if(d > p) {
	d = d - p;
}
```
计算当前轮的乘法结果，加上上一轮的乘法结果，再加上q * p，再除以。循环4轮，最后再判断是否大于p，大于再减掉一个p就是最终的$a*b*2^{-32}\ (mod\ p)$结果。

## q的计算
由[如何高效进行模乘、模幂运算？——蒙哥马利算法](https://blog.csdn.net/a675115471/article/details/107553091)可知：

$q\ =\ (a[0]*b[i]+d_0)*t\ (mod\ 2^{32})$
其中$d_0$，为d的低32位，其实就是d[0];
理论中t的值为：$t=-p^{-1}\ (mod\ 2^{32})$，伪代码为：
``` c
t = 1;
for(i = 1; i < 8; i++) {
	t = t * t * p mod 2^8;
}
t = 2^8 - t;
```
由此可知：$t\ <\ 2^{32}$。


## 蒙哥马利域

蒙哥马利乘法定义是：$a*b*2^{-32}\ (mod\ p)$。
上述可知，最终结果为$a*b*2^{-32}\ (mod\ p)$，并不是我们想要的$a*b\ (mod\ p)$。
可通过，将一个参数乘$2^{32}$，再乘另一个参数，即：
$a' = a*(2^{32})^2*2^{-32}\ (mod\ p) = a*2^{32}\ (mod\ p)$
$a*b\ (mod\ p)=a'*b=a*2^{32}*b*2^{-32}\ (mod\ p)$

## 蒙哥马利公式
针对256-bit的大数，r取：$2^{256}$。

乘法公式：
$modmul(a,b)=a*b*r^{-1}\ (mod\ p)=a*b*2^{-256}\ (mod\ p)$
转换到蒙哥马利域公式：
$modmul(a,r^2)=(a)*(r^2)*r^{-1}\ (mod\ p)=a*r\ (mod\ p)=a*2^{256}\ (mod\ p)$
蒙哥马利域转换到普通大数公式：
$modmul(a*r,1)=(a*r)*(1)*r^{-1}\ (mod\ p)=a\ (mod\ p)$

# RTL附录
## t的Verilog
``` verilog
`define W_J0 64
`define W_SM 256

task J0Cal;
    
    input   [`W_J0-1:0] GMN;
    output  [`W_J0-1:0] J0t;
    
    integer i;
    reg     [`W_J0-1:0] t;
    reg     [`W_J0  :0] R;

    $display("J0Cal is start !");
    begin
        J0t = 1;
        R   = 1 << `W_J0;
        for(i=0;i<`W_J0;i=i+1) begin
            J0t = (J0t * J0t * GMN) % R;
        end
        
        J0t = R - J0t;
        
        $display("J0Cal: N  = %h", GMN);
        $display("J0Cal: R  = %h", R);
        $display("J0Cal: J0 = %h", J0t);
        $display("J0Cal is finish ! ");
        
    end
endtask

`undef W_J0
`undef W_SM
```
## mmm的Verilog
 
``` verilog
`define W_J0 64
`define W_SM 256

task mmm_base;

    input   [`W_SM-1:0] A;
    input   [`W_SM-1:0] B;
    input   [`W_SM-1:0] N;
    input   [`W_J0-1:0] J0;
    output  [`W_SM-1:0] ABR;
    
    integer i,j;
    
    reg     [511:0]     d;
    reg     [511:0]     q;
    reg     [15:0]      k;

    begin
        k = `W_SM/64;
        d = 0;
        q = 0;

        for(i=0;i<k;i=i+1) begin

            // $display("Base: b[%1d] = %h",i,B[((i+1)*`W_J0-1)-:`W_J0]);
            
            q = ((A[63:0]*B[((i+1)*`W_J0-1)-:`W_J0] + d[63:0]) * J0) % 2**`W_J0;

            d = (d + (B[((i+1)*`W_J0-1)-:`W_J0] * A) + q*N) >> `W_J0;
  
        end

        ABR = d[255:0];
        if(ABR > N)
            ABR = ABR - N;

    end
endtask

`undef W_J0
`undef W_SM
```







# 参考文献
* [蒙哥马利算法](http://www.chyitech.com/gmc/mont.html)