# 模逆

# 参考文献
1. 统一架构的ECC与RSA密码处理器的设计.刘兵
2. 模逆算法的分析、改进及测试.谭丽娟，陈 运

# 欧几里得算法
欧几里得算法又称**辗转相除法**，是指用于计算两个非负整数a，b的最大公约数。两个整数的最大公约数是能够同时整除它们的最大的正整数。
应用领域有数学和计算机两个方面。计算公式 `gcd(a,b) = gcd(b,a mod b)`。
辗转相除法基于如下原理：两个整数的最大公约数等于其中较小的数和<mark>两数相除余数</mark>的最大公约数。 

> 
    假如需要求 1997 和 615 两个正整数的最大公约数,用欧几里得算法，是这样进行的：
    1997 ÷ 615 = 3 (余 152)
    615 ÷ 152 = 4(余7)
    152 ÷ 7 = 21(余5)
    7 ÷ 5 = 1 (余2)
    5 ÷ 2 = 2 (余1)
    2 ÷ 1 = 2 (余0)
    至此，最大公约数为1
    以除数和余数反复做除法运算，当余数为 0 时，取当前算式除数为最大公约数
    
``` verilog
`define WNL 256
`define WOP 64

// Input : A B;
// Output: S = A和B的最大公约数;

task gcd;
    input   [`WNL-1:0] A;
    input   [`WNL-1:0] B;
    output  [`WNL-1:0] S;

    reg     [`WNL-1:0] r;
    integer i;

    $display("gcd is start !");
    begin
      
      // 保证 A > B
      if(A < B)begin
        r = A;
        A = B;
        B = r;
      end
      
      // 辗转相除
      do  begin
         r = A % B;
         A = B;
         B = r;
      end
      while((A % B)!=0);
      
      S = B;   
      
    end
    $display("gcd: gcd = %h", S);
    $display("gcd is finish ! ");

endtask

`undef WNL
`undef WOP

```

# 拓展欧几里得算法
扩展欧几里得算法不但能计算(a，b）的最大公约数，而且能计算a模b及b模a的乘法逆元。
扩展欧几里得算法对于最大公约数的计算和普通欧几里得算法是一致的。
计算乘法逆元则显得难以理解：
如果gcd(a，b)=d，则存在m，n，使得d = ma + nb，称呼这种关系为a、b组合整数d，m，n称为组合系数。当d=1时，有 ma + nb = 1 ，此时可以看出m是a模b的乘法逆元，n是b模a的乘法逆元。
> 
    由 ma + nb = 1 可得
    (ma + nb) mod b = 1 : 此时可以看出m是a模b的乘法逆元;
    (ma + nb) mod a = 1 : 此时可以看出n是b模a的乘法逆元。
    
>
    裴蜀定理 ：
    有一个线性不定方程 ax+by=c
    若此方程有解，那么 c=k*gcd(a,b) ，k 为任意正整数
    证明：
    以下 gcd(a,b) 简称 gcd
    ∵ (ax+by) mod gcd=0
    又 c mod gcd=0
    ∴ (ax+by-c) mod gcd=0
    ∴ ax+by≡c (mod gcd)
    证毕
    ∴ 当 ax+by=c 成立时，c=k*gcd
    特殊的：
    当 a，b 互质时，方程满足 ax+by=1


通常谈到最大公因子时, 我们都会提到一个非常基本的事实: **给两个整数 a 与 b, 必存在有整数 x 与 y 使得ax + by = gcd(a,b)**。
有两个数a,b，对它们进行辗转相除法，可得它们的最大公约数。然后，收集辗转相除法中产生的式子，倒回去，可以得到ax+by=gcd(a,b)的整数解。




![](vx_images/151574019236312.png =603x)



